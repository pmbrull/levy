{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Supercharge configs with Jinja templates, typing and custom functions. Documentation : https://pmbrull.github.io/levy/ Source Code : https://github.com/pmbrull/levy Installation \u00b6 Get up and running with $ pip install levy ---> 100% Successfully installed levy This will also bring to your environment PyYAML , Jinja2 and pydantic . Quickstart \u00b6 This project is a lightweight take on configuration parsing with a twist. It supports reading both JSON and YAML files, as well as getting configurations directly from a dict . levy adds a jinja2 layer on top our config files, which allows us to run any Jinja templating syntax on them. Later on, we will also see how to register our own custom functions. Let's suppose we have the following configuration: title : \"L\u00e9vy the cat\" colors : - \"black\" - \"white\" hobby : eating : what : \"anything\" friends : { % set friends = [ \"cartman\" , \"lima\" ] % } { % for friend in friends % } - name : ${ friend } type : \"cat\" { % endfor % } We have a bit of everything: - Root configurations - Simple lists - Nested configurations - Dynamic jinja2 lists as nested configurations We can create our Config object as from levy.config import Config cfg = Config . read_file ( \"test.yaml\" ) As there is the jinja2 layer we might want to check what is the shape of the parsed values. We can do so with cfg._vars . In our case we'll get back something like: { 'title': 'L\u00e9vy the cat', 'colors': ['black', 'white'], 'hobby': { 'eating': { 'what': 'anything' } }, 'friends': [ {'name': 'cartman', 'type': 'cat'}, {'name': 'lima', 'type': 'cat'} ] } OBS: When reading from files and for debugging purposes, we can access the cfg._file var to check what file was parsed. Accessing Values \u00b6 levy dynamically creates Config objects building the whole tree. This means that we can use the same strategy to retrieve data from the root level or any arbitrary nesting. // Check Config level $ cfg Config(\"root\") // Access information as attributes $ cfg.title \"L\u00e9vy the cat\" $ cfg.colors [\"black\", \"white\"] // Even if those are nested dicts $ cfg.hobby Config(\"hobby\") // Chain calls until reaching our values $ cfg.hobby.eating.what \"anything\" Accessing Lists \u00b6 Getting data from a list is the same as for any Config . // Access a list element by name $ cfg.friends.lima Config(lima) // Extract information as usual $ cfg.friends.lima.type cat","title":"Quickstart"},{"location":"#installation","text":"Get up and running with $ pip install levy ---> 100% Successfully installed levy This will also bring to your environment PyYAML , Jinja2 and pydantic .","title":"Installation"},{"location":"#quickstart","text":"This project is a lightweight take on configuration parsing with a twist. It supports reading both JSON and YAML files, as well as getting configurations directly from a dict . levy adds a jinja2 layer on top our config files, which allows us to run any Jinja templating syntax on them. Later on, we will also see how to register our own custom functions. Let's suppose we have the following configuration: title : \"L\u00e9vy the cat\" colors : - \"black\" - \"white\" hobby : eating : what : \"anything\" friends : { % set friends = [ \"cartman\" , \"lima\" ] % } { % for friend in friends % } - name : ${ friend } type : \"cat\" { % endfor % } We have a bit of everything: - Root configurations - Simple lists - Nested configurations - Dynamic jinja2 lists as nested configurations We can create our Config object as from levy.config import Config cfg = Config . read_file ( \"test.yaml\" ) As there is the jinja2 layer we might want to check what is the shape of the parsed values. We can do so with cfg._vars . In our case we'll get back something like: { 'title': 'L\u00e9vy the cat', 'colors': ['black', 'white'], 'hobby': { 'eating': { 'what': 'anything' } }, 'friends': [ {'name': 'cartman', 'type': 'cat'}, {'name': 'lima', 'type': 'cat'} ] } OBS: When reading from files and for debugging purposes, we can access the cfg._file var to check what file was parsed.","title":"Quickstart"},{"location":"#accessing-values","text":"levy dynamically creates Config objects building the whole tree. This means that we can use the same strategy to retrieve data from the root level or any arbitrary nesting. // Check Config level $ cfg Config(\"root\") // Access information as attributes $ cfg.title \"L\u00e9vy the cat\" $ cfg.colors [\"black\", \"white\"] // Even if those are nested dicts $ cfg.hobby Config(\"hobby\") // Chain calls until reaching our values $ cfg.hobby.eating.what \"anything\"","title":"Accessing Values"},{"location":"#accessing-lists","text":"Getting data from a list is the same as for any Config . // Access a list element by name $ cfg.friends.lima Config(lima) // Extract information as usual $ cfg.friends.lima.type cat","title":"Accessing Lists"},{"location":"contributing/","text":"You can install the project requirements with make install . To run the tests, make install_test and make unit . With make precommit_install you can install the pre-commit hooks. To install the package from source, clone the repo, pip install flit and run flit install .","title":"Contributing"},{"location":"defaults/","text":"Accessing Data \u00b6 Being flexible when working with config files is rather helpful. It is common to fall back to default values when some parameter is not informed in our configuration. Instead of extracting the values as attributes , we can __call__ our Config in order to be able to apply defaults at will. // We can access data by call $ cfg ( \"title\" ) \"L\u00e9vy the cat\" // Here we can use defaults $ cfg ( \"not in there\" , default = \"random\" ) \"random\" // We can return `None` as well $ cfg ( \"not in there\" , None ) None Dynamic Access \u00b6 If no default is specified, the call will run the usual attribute retrieval. This is interesting for cases where we need to dynamically get some configuration that should be there. // If the attribute is not there... $ cfg ( \"not in there\" ) AttributeError","title":"Using Defaults"},{"location":"defaults/#accessing-data","text":"Being flexible when working with config files is rather helpful. It is common to fall back to default values when some parameter is not informed in our configuration. Instead of extracting the values as attributes , we can __call__ our Config in order to be able to apply defaults at will. // We can access data by call $ cfg ( \"title\" ) \"L\u00e9vy the cat\" // Here we can use defaults $ cfg ( \"not in there\" , default = \"random\" ) \"random\" // We can return `None` as well $ cfg ( \"not in there\" , None ) None","title":"Accessing Data"},{"location":"defaults/#dynamic-access","text":"If no default is specified, the call will run the usual attribute retrieval. This is interesting for cases where we need to dynamically get some configuration that should be there. // If the attribute is not there... $ cfg ( \"not in there\" ) AttributeError","title":"Dynamic Access"},{"location":"functions/","text":"Environment Variables \u00b6 It is common to have these specific parameters available as env variables, be it our infra or in a CI/CD process. In these situations, we often end up duplicating configurations, which might end up with issues rising from a configuration drift between environments. To ease these scenarios levy provides one functionality out of the box: read environment variables at render time. variable : ${ env('VARIABLE') } default : ${ env('foo', default='bar') } Where the function env is the key name given to a function defined to get env vars with an optional default. If the env variable is not found and no default is provided, we'll get a MissingEnvException . We can then access these values as usual. Registering new functions \u00b6 If we need to apply different functions when rendering the files, we can register them by name before instantiating the Config class. Let's imagine the following YAML file: variable : ${ my_func(1) } foo : ${ bar('x') } We then need to define the behavior of the functions my_func and bar . from levy.config import Config from levy.renderer import render_reg @render_reg . add () # By default, it registers the function name def my_func ( num : int ): return num + 1 @render_reg . add ( 'bar' ) # Name can be overwritten if required def upper ( s : str ): return s . upper () cfg = Config . read_file ( \"<file>\" ) // We can access the results of the functions as usual $ cfg.variable 2 $ cfg.foo \"X\" Note how we registered my_func with the same name it appeared in the YAML. However, the name is completely arbitrary, and we can pass the function upper with the name bar . With this approach one can add even further dynamism to our config files. Registry \u00b6 To peek into the registry state, we can run: render_reg . registry Which in the example will show us {'env': <function __main__.get_env(conf_str: str, default: Optional[str] = None) -> str>, 'my_func': <function __main__.my_func(num: int)>, 'bar': <function __main__.upper(s: str)>} OBS: If you take a look at the source code, the env function has been defined in the registry as shown here.","title":"Render Custom Functions"},{"location":"functions/#environment-variables","text":"It is common to have these specific parameters available as env variables, be it our infra or in a CI/CD process. In these situations, we often end up duplicating configurations, which might end up with issues rising from a configuration drift between environments. To ease these scenarios levy provides one functionality out of the box: read environment variables at render time. variable : ${ env('VARIABLE') } default : ${ env('foo', default='bar') } Where the function env is the key name given to a function defined to get env vars with an optional default. If the env variable is not found and no default is provided, we'll get a MissingEnvException . We can then access these values as usual.","title":"Environment Variables"},{"location":"functions/#registering-new-functions","text":"If we need to apply different functions when rendering the files, we can register them by name before instantiating the Config class. Let's imagine the following YAML file: variable : ${ my_func(1) } foo : ${ bar('x') } We then need to define the behavior of the functions my_func and bar . from levy.config import Config from levy.renderer import render_reg @render_reg . add () # By default, it registers the function name def my_func ( num : int ): return num + 1 @render_reg . add ( 'bar' ) # Name can be overwritten if required def upper ( s : str ): return s . upper () cfg = Config . read_file ( \"<file>\" ) // We can access the results of the functions as usual $ cfg.variable 2 $ cfg.foo \"X\" Note how we registered my_func with the same name it appeared in the YAML. However, the name is completely arbitrary, and we can pass the function upper with the name bar . With this approach one can add even further dynamism to our config files.","title":"Registering new functions"},{"location":"functions/#registry","text":"To peek into the registry state, we can run: render_reg . registry Which in the example will show us {'env': <function __main__.get_env(conf_str: str, default: Optional[str] = None) -> str>, 'my_func': <function __main__.my_func(num: int)>, 'bar': <function __main__.upper(s: str)>} OBS: If you take a look at the source code, the env function has been defined in the registry as shown here.","title":"Registry"},{"location":"json/","text":"Rendering JSON Files \u00b6 levy supports JSON file as well as YAML. All the features remain the same, however, we need to make sure that the JSON file we write is a correctly formatted JSON after the render phase, which might be a bit tricky at times. OBS: Note that the added difficulty is only for Jinja templating, as we need to take care about putting all the quotes and commas. Let's revisit the first example we saw, and how it would look like as a JSON file: { \"title\" : \"L\u00e9vy the cat\" , \"colors\" : [ \"black\" , \"white\" ], \"hobby\" : { \"eating\" : { \"what\" : \"anything\" } }, \"friends\" : [ { % se t fr ie n ds = [ \"cartman\" , \"lima\" ] % } { % f or fr ie n d i n fr ie n ds % } { \"name\" : \"${ friend }\" , \"type\" : \"cat\" } { % i f loop.i n dex 0 < fr ie n ds|le n g t h - 1 % } , { % e n di f % } { % e n d f or % } ] } As you can see, most of it is the same. However, in the friends list, we need to add specific logic to add commas , if we have not reached the end of the loop. Afterwards, the API remains: from levy.config import Config cfg = Config . read_file ( \"test.json\" )","title":"JSON Files"},{"location":"json/#rendering-json-files","text":"levy supports JSON file as well as YAML. All the features remain the same, however, we need to make sure that the JSON file we write is a correctly formatted JSON after the render phase, which might be a bit tricky at times. OBS: Note that the added difficulty is only for Jinja templating, as we need to take care about putting all the quotes and commas. Let's revisit the first example we saw, and how it would look like as a JSON file: { \"title\" : \"L\u00e9vy the cat\" , \"colors\" : [ \"black\" , \"white\" ], \"hobby\" : { \"eating\" : { \"what\" : \"anything\" } }, \"friends\" : [ { % se t fr ie n ds = [ \"cartman\" , \"lima\" ] % } { % f or fr ie n d i n fr ie n ds % } { \"name\" : \"${ friend }\" , \"type\" : \"cat\" } { % i f loop.i n dex 0 < fr ie n ds|le n g t h - 1 % } , { % e n di f % } { % e n d f or % } ] } As you can see, most of it is the same. However, in the friends list, we need to add specific logic to add commas , if we have not reached the end of the loop. Afterwards, the API remains: from levy.config import Config cfg = Config . read_file ( \"test.json\" )","title":"Rendering JSON Files"},{"location":"lists/","text":"Jinja \u00b6 Having a jinja2 layer on our config files helps us centralise information and keep configurations as DRY as possible. Recall our test YAML: title : \"L\u00e9vy the cat\" colors : - \"black\" - \"white\" hobby : eating : what : \"anything\" friends : { % set friends = [ \"cartman\" , \"lima\" ] % } { % for friend in friends % } - name : ${ friend } type : \"cat\" { % endfor % } Namedtuples \u00b6 The colors list has nothing fancy in it, as we have simple types. However, we want to parse nested configurations as Config , while being able to access them by name as attributes. // Access a list element by name $ cfg.friends.lima Config(lima) // Extract information as usual $ cfg.friends.lima.type cat To fit this spot we have namedtuple s. The list attribute becomes a namedtuple where the properties are the name s of the nested items. If we check the type... // Check list instance $ isinstance ( cfg.friends, tuple ) True Identifiers \u00b6 name is set as the default identifier, i.e., will be used to name the namedtuple , but we can pass others as parameter. For example, we can set it as id if we had the following YAML: [ ... ] friends : { % set friends = [ \"cartman\" , \"lima\" ] % } { % for friend in friends % } - id : ${ friend } type : \"cat\" { % endfor % } from levy.config import Config cfg = Config . read_file ( file , list_id = \"id\" ) Handling Exceptions \u00b6 If we encounter an error while defining the namedtuple s structure, we will get a ListParseException . We should then check how are we defining the lists and our list_id argument. OBS: Note that the list_id field should be a valid namedtuple key. This means that it cannot contain spaces or other not supported special characters.","title":"Nested Config Lists"},{"location":"lists/#jinja","text":"Having a jinja2 layer on our config files helps us centralise information and keep configurations as DRY as possible. Recall our test YAML: title : \"L\u00e9vy the cat\" colors : - \"black\" - \"white\" hobby : eating : what : \"anything\" friends : { % set friends = [ \"cartman\" , \"lima\" ] % } { % for friend in friends % } - name : ${ friend } type : \"cat\" { % endfor % }","title":"Jinja"},{"location":"lists/#namedtuples","text":"The colors list has nothing fancy in it, as we have simple types. However, we want to parse nested configurations as Config , while being able to access them by name as attributes. // Access a list element by name $ cfg.friends.lima Config(lima) // Extract information as usual $ cfg.friends.lima.type cat To fit this spot we have namedtuple s. The list attribute becomes a namedtuple where the properties are the name s of the nested items. If we check the type... // Check list instance $ isinstance ( cfg.friends, tuple ) True","title":"Namedtuples"},{"location":"lists/#identifiers","text":"name is set as the default identifier, i.e., will be used to name the namedtuple , but we can pass others as parameter. For example, we can set it as id if we had the following YAML: [ ... ] friends : { % set friends = [ \"cartman\" , \"lima\" ] % } { % for friend in friends % } - id : ${ friend } type : \"cat\" { % endfor % } from levy.config import Config cfg = Config . read_file ( file , list_id = \"id\" )","title":"Identifiers"},{"location":"lists/#handling-exceptions","text":"If we encounter an error while defining the namedtuple s structure, we will get a ListParseException . We should then check how are we defining the lists and our list_id argument. OBS: Note that the list_id field should be a valid namedtuple key. This means that it cannot contain spaces or other not supported special characters.","title":"Handling Exceptions"},{"location":"references/","text":"References \u00b6 pyconfs as inspiration. pydantic - implementing the validation and data filling. typer and @tiangolo - thanks for preparing such amazing docs. JS and CSS ported from there.","title":"References"},{"location":"references/#references","text":"pyconfs as inspiration. pydantic - implementing the validation and data filling. typer and @tiangolo - thanks for preparing such amazing docs. JS and CSS ported from there.","title":"References"},{"location":"schema/","text":"Pydantic \u00b6 At some point it might be interesting to make sure that the YAML we are reading follows some standards. That is why we have introduced the ability to pass a schema our file needs to follow. This feature is supported by Pydantic , and not only helps us to validate the schema, but even updating the values we're reading with Optionals and defaults. Let's continue working with our example YAML: title : \"L\u00e9vy the cat\" colors : - \"black\" - \"white\" hobby : eating : what : \"anything\" friends : { % set friends = [ \"cartman\" , \"lima\" ] % } { % for friend in friends % } - name : ${ friend } type : \"cat\" { % endfor % } We can get this running as from typing import Optional , List , Dict from levy.config import Config from pydantic import BaseModel class Friends ( BaseModel ): name : str type : str fur : str = \"soft\" class Kitten ( BaseModel ): title : str age : Optional [ int ] colors : List [ str ] hobby : Dict [ str , Dict [ str , str ]] friends : List [ Friends ] cfg = Config . read_file ( \"<file>\" , datatype = Kitten ) Note how this adds even another layer of flexibility, as after reading the config we will have all the data we might require available to use. // We have the data attribute now hosting the data class $ cfg.data Kitten(title='L\u00e9vy the cat', age=None, colors=['black', 'white'], hobby={'eating': {'what': 'anything'}}, friends=[Friends(name='cartman', type='cat', fur='soft'), Friends(name='lima', type='cat', fur='soft')]) // Optional values become None $ cfg.age None // We have missing values with their default $ cfg.friends.lima.fur \"soft\"","title":"Schema Validation"},{"location":"schema/#pydantic","text":"At some point it might be interesting to make sure that the YAML we are reading follows some standards. That is why we have introduced the ability to pass a schema our file needs to follow. This feature is supported by Pydantic , and not only helps us to validate the schema, but even updating the values we're reading with Optionals and defaults. Let's continue working with our example YAML: title : \"L\u00e9vy the cat\" colors : - \"black\" - \"white\" hobby : eating : what : \"anything\" friends : { % set friends = [ \"cartman\" , \"lima\" ] % } { % for friend in friends % } - name : ${ friend } type : \"cat\" { % endfor % } We can get this running as from typing import Optional , List , Dict from levy.config import Config from pydantic import BaseModel class Friends ( BaseModel ): name : str type : str fur : str = \"soft\" class Kitten ( BaseModel ): title : str age : Optional [ int ] colors : List [ str ] hobby : Dict [ str , Dict [ str , str ]] friends : List [ Friends ] cfg = Config . read_file ( \"<file>\" , datatype = Kitten ) Note how this adds even another layer of flexibility, as after reading the config we will have all the data we might require available to use. // We have the data attribute now hosting the data class $ cfg.data Kitten(title='L\u00e9vy the cat', age=None, colors=['black', 'white'], hobby={'eating': {'what': 'anything'}}, friends=[Friends(name='cartman', type='cat', fur='soft'), Friends(name='lima', type='cat', fur='soft')]) // Optional values become None $ cfg.age None // We have missing values with their default $ cfg.friends.lima.fur \"soft\"","title":"Pydantic"}]}